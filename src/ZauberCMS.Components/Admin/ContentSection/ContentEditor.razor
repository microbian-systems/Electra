@using System.Globalization
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Localization
@using ZauberCMS.Core.Shared
@using ZauberCMS.Core.Plugins
@using ZauberCMS.Components.Editors.Dialogs
@using ZauberCMS.Components.Editors.Models
@using ZauberCMS.Core.Content.Parameters
@using ZauberCMS.Core.Content.Mapping
@using ZauberCMS.Core.Content.Models
@using ZauberCMS.Core.Membership.Models
@using ZauberCMS.Core.Shared.Models
@using ZauberCMS.Core.Shared.Services

@implements IDisposable

@if (Loading)
{
    <div class="pt-4 flex items-center justify-center">
        <RadzenProgressBarCircular ShowValue="true" Mode="ProgressBarMode.Indeterminate"
                                   Size="ProgressBarCircularSize.Medium">
            <Template>Loading</Template>
        </RadzenProgressBarCircular>
    </div>
}
else
{
    @if (ContentType != null && WorkingCopy != null)
    {
        <EditForm @ref="@ContentForm" Model="@WorkingCopy">

            <RadzenRow class="rz-pb-2">
                <RadzenTextBox Style="width: 100%;" Name="Name" Placeholder="Name" Value="@WorkingCopy!.Name"
                               ValueChanged="@((string name) => { WorkingCopy.Name = name; })" aria-label="Name"/>
                <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Left"
                             AlignItems="AlignItems.Center" Gap="0.2rem">
                    <RadzenIcon Icon="schedule" Style="line-height: 20px; height: 20px; font-size: 20px;"
                                IconStyle="IconStyle.Light"/>
                    <RadzenText TextStyle="TextStyle.Caption" Style="margin: 0; padding: 0;">Last
                        Updated: @WorkingCopy.DateUpdated.Humanize()</RadzenText>
                    @if (WorkingCopy.UnpublishedContent != null)
                    {
                        <RadzenText TextStyle="TextStyle.Caption" Style="margin: 0; padding: 0; color: #e85d5d">
                            (Contains Unpublished Changes)
                        </RadzenText>
                    }
                </RadzenStack>
            </RadzenRow>

            <RadzenTabs @ref="Tabs" RenderMode="TabRenderMode.Client" Change="@(i => TabChange(i))">
                <Tabs>
                    @foreach (var tab in OrderedTabs.Where(x => !x.IsSystemTab).OrderBy(x => x.SortOrder))
                    {
                        <RadzenTabsItem>
                            <Template Context="tabContext">
                                @tab.Name
                            </Template>
                            <ChildContent>
                                <RadzenStack Gap="1rem">
                                    @foreach (var property in AllProperties
                                                      .Where(x => x.TabAlias == tab.Alias)
                                                      .OrderBy(x => x.SortOrder))
                                    {
                                        if (property.Component != null)
                                        {
                                            AllContentTypeProperties.TryGetValue(property.Component, out var contentPropertyComponent);
                                            if (contentPropertyComponent != null)
                                            {
                                                AllContentValues.TryGetValue(property.Id, out var contentValue);
                                                if (contentValue != null)
                                                {
                                                    <EditorRow FullWidth="@(property.FullWidth)">
                                                        <LeftColumn>
                                                            <PropertyInfo Name="@property.Name" Alias="@property.Alias"
                                                                          Description="@property.Description"/>
                                                        </LeftColumn>
                                                        <CentreColumn>
                                                            <DynamicContentProperty
                                                                ComponentType="@contentPropertyComponent"
                                                                Settings="@property.Settings"
                                                                Content="@WorkingCopy"
                                                                Value="@contentValue.Value"
                                                                PropertyAlias="@contentValue.Alias"
                                                                ValueChanged="@(value => UpdateProperty(contentValue.ContentTypePropertyId, value))"
                                                                ChangesPending="@HandleBlockListChanges"/>
                                                        </CentreColumn>
                                                    </EditorRow>
                                                }
                                            }
                                        }
                                    }

                                </RadzenStack>
                            </ChildContent>
                        </RadzenTabsItem>
                    }

                    @if (IsBlockList != true)
                    {
                        <RadzenTabsItem Text="System">
                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Id"/>
                                </LeftColumn>
                                <CentreColumn>
                                    @WorkingCopy.Id
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Content View"
                                                  Description="The views available to render this content in the front end"/>
                                </LeftColumn>
                                <CentreColumn>
                                    <RadzenDropDown @bind-Value="@WorkingCopy.ViewComponent"
                                                    Data="@ContentViews"
                                                    TextProperty="Name"
                                                    ValueProperty="FullName"
                                                    Style="width: 100%; max-width: 400px;"/>
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Url"
                                                  Description="The url in the browser bar to show this page"/>
                                </LeftColumn>
                                <CentreColumn>
                                    @* ReSharper disable CSharpWarnings::CS0618 *@
                                    <RadzenTextBox Style="width: 100%;" Name="Url" @bind-Value="@WorkingCopy.Url"/>
                                    @* ReSharper restore CSharpWarnings::CS0618 *@
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Hide From Navigation"
                                                  Description="Optional: Hides this page from any navigation if the developer has integrated it"/>
                                </LeftColumn>
                                <CentreColumn>
                                    <RadzenSwitch Name="HideFromNavigation" @bind-Value="@WorkingCopy.HideFromNavigation"/>
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Internal Redirect"
                                                  Description="Choose a different page to show when the user browses to this pages url"/>
                                </LeftColumn>
                                <CentreColumn>
                                    <ContentPickerProperty
                                        Value="@WorkingCopy.InternalRedirectIdAsString"
                                        Settings="@(JsonSerializer.Serialize(new ContentPickerSettings { MaxAllowed = 1 }))"
                                        ValueChanged="@(e => WorkingCopy.InternalRedirectIdAsString = e.ToString())"/>
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Date Created"/>
                                </LeftColumn>
                                <CentreColumn>
                                    <RadzenDatePicker @bind-Value="@WorkingCopy.DateCreated" Name="ContentDateCreated"
                                                      DateFormat="@(CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern)"/>
                                </CentreColumn>
                            </EditorRow>

                            <EditorRow>
                                <LeftColumn>
                                    <PropertyInfo Name="Last Updated"/>
                                </LeftColumn>
                                <CentreColumn>
                                    @WorkingCopy.DateUpdated.Humanize()
                                </CentreColumn>
                            </EditorRow>

                            @if (LastUpdatedBy != null)
                            {
                                <EditorRow>
                                    <LeftColumn>
                                        <PropertyInfo Name="Updated By"/>
                                    </LeftColumn>
                                    <CentreColumn>
                                        <div class="flex justify-start items-center space-x-2">
                                            <RadzenGravatar Email="@LastUpdatedBy?.Email"/>
                                            <span>@(LastUpdatedBy?.Name)</span>
                                        </div>
                                    </CentreColumn>
                                </EditorRow>
                            }

                        </RadzenTabsItem>

                        <RadzenTabsItem Text="Versions">
                            <ContentVersions ContentId="@WorkingCopy.Id" />
                        </RadzenTabsItem>
                    }
                </Tabs>
            </RadzenTabs>
            @if (!WorkingCopy.Deleted)
            {
                <div class="flex justify-between items-center">
                    @if (!ElementTypesOnly)
                    {
                        <div>
                            <RadzenBreadCrumb>
                                <RadzenBreadCrumbItem Text=" " />
                                @foreach (var content in Breadcrumb.SkipLast(1))
                                {
                                    <RadzenBreadCrumbItem
                                        Path="@($"{Urls.AdminUpdateContent}/{content.Id}")"
                                        Text="@(content.Name?.Length > 30 ? content.Name[..30] + "..." : content.Name)"/>
                                }
                            </RadzenBreadCrumb>
                        </div>
                    }

                    @if (IsBlockList == true)
                    {
                            <div class="flex items-center justify-center gap-2">
                                <div class="text-sm">Published</div>
                                <RadzenSwitch @bind-Value="@WorkingCopy!.Published" />
                            </div>
                            <div class="flex items-center justify-center gap-2">
                                <RadzenButton Click="@Cancel" Text="Cancel" />
                                <RadzenButton Click=@(() => Save(null, false)) Icon="save" ButtonStyle="ButtonStyle.Success"
                                              Text="Save"/>
                            </div>
                    }
                    else
                    {
                        <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Right"
                                     AlignItems="AlignItems.Center">
                            @if (WorkingCopy!.UnpublishedContentId != null)
                            {
                                <RadzenButton Click=@(args => ClearUnpublishedChanges()) Shade="Shade.Lighter"
                                              Text="Clear Changes"/>
                            }
                            @if (WorkingCopy!.Published)
                            {
                                <RadzenButton Click=@(args => Save(null, true)) Text="Unpublish"/>
                            }
                            <RadzenSplitButton Click=@(args => Save(args, false)) Icon="save"
                                               ButtonStyle="ButtonStyle.Success" Text="Save &amp; Publish">
                                <ChildContent>
                                    <RadzenSplitButtonItem Text="Save Only" Value="1"/>
                                </ChildContent>
                            </RadzenSplitButton>
                        </RadzenStack>
                    }
                </div>
            }
        </EditForm>
    }
    else
    {
        <ListContentTypes ContentTypeSelected="@UpdateContentTypeId"
                          RootOnly="@RootOnly"
                          ElementTypesOnly="@ElementTypesOnly"
                          ParentId="@ParentId"
                          AllowedElementTypeIds="@AllowedElementTypeIds" />
    }
}

@code {

    [CascadingParameter] BlazoredModalInstance ContentEditorModal { get; set; } = null!;
    [CascadingParameter] IModalService ModalService { get; set; } = null!;
    [Inject] public NotificationService NotificationService { get; set; } = null!;
    [Inject] public ExtensionManager ExtensionManager { get; set; } = null!;
    [Inject] public AppState AppState { get; set; } = null!;
    [Inject] public TreeState TreeState { get; set; } = null!;
    [Inject] public AuthenticationStateProvider AuthenticationStateProvider { get; set; } = null!;
    [Inject] public ValidateService<Content> ValidateService { get; set; } = null!;

    [Inject] public IStringLocalizer<SharedResource> Localizer { get; set; } = null!;

    [Parameter] public Guid? ContentId { get; set; }
    [Parameter] public Guid? ParentId { get; set; }
    [Parameter] public Guid? NestedParentId { get; set; }
    [Parameter] public bool? IsBlockList { get; set; }
    [Parameter] public string? DefaultName { get; set; }
    [Parameter] public List<Guid>? AllowedElementTypeIds { get; set; }
    [Parameter] public Action<BlockListChanges>? OnBlockListChanges { get; set; }
    [Parameter] public Content? Content { get; set; }

    private EditForm ContentForm { get; set; } = null!;
    private ContentType? ContentType { get; set; }
    private Dictionary<string, Type> AllContentTypeProperties { get; set; } = new();
    private List<ContentViewName> ContentViews { get; set; } = [];
    private Dictionary<Guid, ContentPropertyValue> AllContentValues { get; set; } = new();

    //private Dictionary<string, string> AvailableContentViews { get; set; } = new();
    private int SelectedTabIndex { get; set; }
    private RadzenTabs? Tabs { get; set; }
    private bool RootOnly => IsBlockList != true && ContentId == null && ParentId == null;
    private bool ElementTypesOnly => IsBlockList == true;
    private AuthenticationState AuthState { get; set; } = null!;
    private List<Tab> OrderedTabs { get; set; } = [];
    private List<PropertyType> AllProperties { get; set; } = [];
    private List<ContentType> SelectedCompositions { get; set; } = [];
    private List<Content> Breadcrumb { get; set; } = [];
    private CmsUser? LastUpdatedBy { get; set; }
    private bool Loading { get; set; } = true;
    private BlockListChanges? PendingBlockListChanges { get; set; }
    private Content? WorkingCopy { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        Loading = true;

        // Subscribe to content change events to refresh when content is modified externally
        AppState.OnContentChanged += HandleContentChanged;

        AllContentTypeProperties = ExtensionManager.GetImplementations<IContentProperty>(true);
        AuthState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        if (Content == null)
        {
            // If no content is passed in
            if (ContentId != null)
            {
                await RefreshContent(); // RefreshContent handles WorkingCopy creation and syncing
            }
            else
            {
                // Create new content
                if (ParentId != null)
                {
                    Content = new Content
                    {
                        ParentId = ParentId,
                        IsRootContent = false
                    };
                }
                else
                {
                    Content = new Content
                    {
                        IsRootContent = IsBlockList != true
                    };
                }

                if (IsBlockList == true)
                {
                    Content!.RelatedContentId = NestedParentId;
                    Content!.IsNestedContent = true;
                    Content!.Published = true;
                    if(Content?.Name.IsNullOrWhiteSpace() == true && !DefaultName.IsNullOrWhiteSpace())
                    {
                        Content.Name = DefaultName;
                    }
                }
                
                WorkingCopy = CreateWorkingCopy(Content!);
            }
        }
        else
        {
            // We have a content item passed in - create a working copy to avoid modifying the original
            WorkingCopy = CreateWorkingCopy(Content);
            
            ContentType = await ContentService.GetContentTypeAsync(new GetContentTypeParameters { Id = WorkingCopy.ContentTypeId });
            if (ContentType == null)
            {
                NotificationService.ShowErrorNotification("Unable to find a content type for the content?");
            }
            else
            {
                await SyncProperties(WorkingCopy, ContentType);
            }
        }

        Loading = false;
    }
    
    private void InitializeContentViews()
    {
        ContentViews = ContentType?.AvailableContentViews.Select(x =>
        {
            var splitName = x.Split('.');
            return new ContentViewName
            {
                Name = splitName.Last(),
                FullName = x
            };
        }).ToList() ?? [];
    }

    private async Task RefreshContent()
    {
        if (ContentId != null)
        {
            Content = await ContentService.GetContentAsync(new GetContentParameters { Id = ContentId!.Value, IncludeUnpublished = true, IncludeUnpublishedContent = true });
            ContentType = await ContentService.GetContentTypeAsync(new GetContentTypeParameters { Id = Content!.ContentTypeId });
            
            if (Content.UnpublishedContent != null)
            {
                // Replace the Content with the Json one
                Content.UnpublishedContent.JsonContent.MapTo(Content);
                Content.PropertyData = Content.UnpublishedContent.JsonContent.PropertyData;
            }

            // Always create WorkingCopy from Content, even if ContentType fails to load
            WorkingCopy = CreateWorkingCopy(Content);
            
            if (ContentType == null)
            {
                NotificationService.ShowErrorNotification("Unable to find content type for this content");
            }
            else
            {
                await SyncProperties(WorkingCopy, ContentType);
                InitializeContentViews();
            }
        }
    }

    private void TabChange(int i)
    {
        SelectedTabIndex = i;
    }

    private Task UpdateProperty(Guid ctpId, string value)
    {
        var property = WorkingCopy?.PropertyData.FirstOrDefault(p => p.ContentTypePropertyId == ctpId);
        if (property != null)
        {
            property.Value = value;
            property.DateUpdated = DateTime.UtcNow;
            
            // Invalidate the cached ContentValues so GetValue() returns updated data
            // Critical for nested block lists where PropertyData is modified in-memory
            WorkingCopy?.InvalidateContentValuesCache();
        }

        return Task.CompletedTask;
    }

    private async Task CompositionsInit()
    {
        // Get these content properties
        AllProperties = ContentType!.ContentProperties;

        if (!ContentType.IsComposition)
        {
            var compositions = await ContentService.QueryContentTypesAsync(new QueryContentTypesParameters { OnlyCompositions = true, AmountPerPage = 100 });

            if (ContentType.CompositionIds.Any())
            {
                SelectedCompositions = compositions.Items.Where(x => ContentType.CompositionIds.Contains(x.Id)).ToList();

                // Now append any composition properties
                foreach (var selectedComposition in SelectedCompositions)
                {
                    AllProperties.AddRange(selectedComposition.ContentProperties);
                }
            }
        }
    }

    private void SortTabsInOrder()
    {
        OrderedTabs = ContentType!.Tabs.OrderBy(x => x.SortOrder).ToList();
        foreach (var selectedComposition in SelectedCompositions)
        {
            foreach (var selectedCompositionTab in selectedComposition.Tabs.Where(x => !x.IsSystemTab).OrderBy(x => x.SortOrder))
            {
                if (OrderedTabs.All(x => x.Alias != selectedCompositionTab.Alias))
                {
                    selectedCompositionTab.IsCompositionTab = true;
                    OrderedTabs.Add(selectedCompositionTab);
                }
            }
        }
    }

    private async Task SyncProperties(Content content, ContentType contentType)
    {
        if (content.LastUpdatedById != null)
        {
            LastUpdatedBy = await MembershipService.GetUser(content.LastUpdatedById);
        }

        var toRemove = new List<ContentPropertyValue>();

        await CompositionsInit();
        SortTabsInOrder();

        // Check for properties that were removed
        foreach (var cpd in content.PropertyData)
        {
            var existsInContentType = AllProperties.Any(x => x.Id == cpd.ContentTypePropertyId);
            if (!existsInContentType)
            {
                // Mark for removal
                toRemove.Add(cpd);
            }
        }

        // Remove the properties
        foreach (var tr in toRemove)
        {
            content.PropertyData.Remove(tr);
        }

        // Check for properties to add
        foreach (var ctp in AllProperties)
        {
            var exists = content.PropertyData.FirstOrDefault(x => x.ContentTypePropertyId == ctp.Id);
            if (exists == null)
            {
                // Add it
                content.PropertyData.Add(new ContentPropertyValue
                {
                    ContentTypePropertyId = ctp.Id,
                    Alias = ctp.Alias!,
                    ContentId = content.Id
                });
            }
        }

        // Invalidate cached ContentValues after modifying PropertyData
        content.InvalidateContentValuesCache();

        AllContentValues = content.PropertyData.ToDictionary(x => x.ContentTypePropertyId, x => x);
        //AvailableContentViews = contentType.AvailableContentViews.ToDictionary(x => x.GetLastPart(), x => x);

        if (content.ViewComponent.IsNullOrWhiteSpace() && contentType.AvailableContentViews.Any())
        {
            content.ViewComponent = contentType.AvailableContentViews.FirstOrDefault()!;
        }
        
        // Breadcrumb
        if (content.Path.Count > 1)
        {
            var breadcrumb = await ContentService.QueryContentAsync(new QueryContentParameters { Ids = content.Path });
            if (breadcrumb.Items.Any())
            {
                Breadcrumb = breadcrumb.Items
                    .OrderBy(item => content.Path.IndexOf(item.Id))
                    .ToList();
            }   
        }

    }

    private async Task UpdateContentTypeId(Guid contentTypeId)
    {
        ContentType = await ContentService.GetContentTypeAsync(new GetContentTypeParameters { Id = contentTypeId });
        if (ContentType == null)
        {
            NotificationService.ShowErrorNotification("Content Type does not exist");
        }
        else
        {
            // Need to set the ContentType is this is new content
            if (ContentId == null)
            {
                WorkingCopy!.ContentTypeId = ContentType.Id;
            }

            await SyncProperties(WorkingCopy!, ContentType);
            InitializeContentViews();
        }
    }

    private async Task ClearUnpublishedChanges()
    {
        var removeUnpublishedContent = await ContentService.ClearUnpublishedContentAsync(new ClearUnpublishedContentParameters { ContentId = WorkingCopy!.Id });
        if (removeUnpublishedContent.Success)
        {
            await RefreshContent();
            await AppState.NotifyContentSaved(WorkingCopy, AuthState.User.GetUserName()!);
        }
        else
        {
            NotificationService.Notify(new NotificationMessage { Severity = NotificationSeverity.Error, Summary = $"{WorkingCopy!.Name} Error", Detail = removeUnpublishedContent.Messages.MessagesAsString(), Duration = 4000 });
        }
    }

    private async Task Cancel()
    {
        await ContentEditorModal.CloseAsync(ModalResult.Cancel());
    }

    private async Task HandleContentChanged(ZauberCMS.Core.Content.Models.Content? content, string username)
    {
        // Refresh content when it changes externally (e.g., version restored)
        // Only refresh if this is the currently loaded content
        if (ContentId != null && (content == null || content.Id == ContentId))
        {
            await RefreshContent();
        }
    }

    private void HandleBlockListChanges(BlockListChanges changes)
    {
        // Store the pending changes to be processed during save
        PendingBlockListChanges = changes;
        OnBlockListChanges?.Invoke(changes);

        // Trigger re-rendering so previews update with latest changes
        StateHasChanged();
    }

    private async Task<HandlerResult<bool>> ProcessBlockListChanges()
    {
        var result = new HandlerResult<bool> { Success = true, Entity = true };
        
        if (PendingBlockListChanges == null) return result;

        // Deduplicate change lists by ContentId to avoid saving the same item multiple times
        var addedItems = PendingBlockListChanges.AddedItems
            .GroupBy(x => x.Id)
            .Select(g => g.Last())
            .ToList();

        var updatedItems = PendingBlockListChanges.UpdatedItems
            .GroupBy(x => x.Id)
            .Select(g => g.Last())
            .ToList();

        var deletedItems = PendingBlockListChanges.DeletedItems
            .GroupBy(x => x.Id)
            .Select(g => g.Last())
            .ToList();

        // Remove any items from added/updated that are in the deleted list
        var deletedIds = deletedItems.Select(x => x.Id).ToHashSet();
        addedItems = addedItems.Where(x => !deletedIds.Contains(x.Id)).ToList();
        updatedItems = updatedItems.Where(x => !deletedIds.Contains(x.Id)).ToList();

        // Process added items
        foreach (var addedItem in addedItems)
        {
            var saveParams = new SaveContentParameters { Content = addedItem };
            var saveResult = await ContentService.SaveContentAsync(saveParams);
            if (!saveResult.Success)
            {
                result.Success = false;
                result.Messages.AddRange(saveResult.Messages);
                NotificationService.ShowNotifications(saveResult.Messages);
            }
        }

        // Process updated items
        foreach (var updatedItem in updatedItems)
        {
            var saveParams = new SaveContentParameters { Content = updatedItem };
            var saveResult = await ContentService.SaveContentAsync(saveParams);
            if (!saveResult.Success)
            {
                result.Success = false;
                result.Messages.AddRange(saveResult.Messages);
                NotificationService.ShowNotifications(saveResult.Messages);
            }
        }

        // Process deleted items
        foreach (var deletedItem in deletedItems)
        {
            var deleteParams = new DeleteContentParameters { ContentId = deletedItem.Id, MoveToRecycleBin = false };
            var deleteResult = await ContentService.DeleteContentAsync(deleteParams);
            if (!deleteResult.Success)
            {
                result.Success = false;
                result.Messages.AddRange(deleteResult.Messages);
                NotificationService.ShowNotifications(deleteResult.Messages);
            }
        }

        // Clear the pending changes after processing
        PendingBlockListChanges = null;
        
        return result;
    }

    private async Task Save(RadzenSplitButtonItem? item, bool unpublish)
    {
        if (await ValidateService.CanSave(WorkingCopy!))
        {
            if (IsBlockList == true)
            {
                // For block list items, Published state is controlled by the toggle switch
                // No need to manipulate it here - just save and return
                await ContentEditorModal.CloseAsync(ModalResult.Ok(WorkingCopy));
            }
            else
            {
                var saveContentCommand = new SaveContentParameters();

                if (unpublish)
                {
                    WorkingCopy!.Published = false;
                }
                else
                {
                    if (item == null)
                    {
                        WorkingCopy!.Published = true;
                    }
                    else if (ContentId != null && WorkingCopy!.Published)
                    {
                        // Content exists and is already published, so need to save the unpublished changes only
                        saveContentCommand.SaveUnpublishedOnly = true;
                    }
                }

                saveContentCommand.Content = WorkingCopy;
                var result = await ContentService.SaveContentAsync(saveContentCommand);

                // Process any pending block list changes after main content is saved (so block list items get correct parent ID)
                HandlerResult<bool>? blockListResult = null;
                if (PendingBlockListChanges != null)
                {
                    blockListResult = await ProcessBlockListChanges();
                }

                // Determine overall success
                var overallSuccess = result.Success && (blockListResult == null || blockListResult.Success);
                
                // Show appropriate notification based on all results
                if (overallSuccess)
                {
                    NotificationService.Notify(new NotificationMessage 
                    { 
                        Severity = NotificationSeverity.Success, 
                        Summary = $"{WorkingCopy!.Name} Saved", 
                        Detail = "", 
                        Duration = 4000 
                    });
                }
                else
                {
                    var errorDetail = result.Success ? "Some nested content failed to save" : result.Messages.MessagesAsString();
                    if (blockListResult != null && !blockListResult.Success)
                    {
                        errorDetail += (errorDetail.Length > 0 ? ". " : "") + blockListResult.Messages.MessagesAsString();
                    }
                    
                    NotificationService.Notify(new NotificationMessage 
                    { 
                        Severity = NotificationSeverity.Error, 
                        Summary = $"{WorkingCopy!.Name} Error", 
                        Detail = errorDetail, 
                        Duration = 6000 
                    });
                }

                // Only proceed with post-save actions if save was successful
                if (overallSuccess)
                {
                    if (ParentId != null)
                    {
                        // If we are creating or saving a child item, make sure the parent is open
                        if (!TreeState.IsNodeExpanded(ParentId.Value))
                        {
                        TreeState.ClearChildCache(ParentId.Value);
                            TreeState.NodeExpanded(ParentId.Value);
                        }
                    }

                    await AppState.NotifyContentSaved(WorkingCopy, AuthState.User.GetUserName()!);

                    // If opened as a dialog, close it instead of navigating
                    if (ContentEditorModal != null)
                    {
                        await ContentEditorModal.CloseAsync(ModalResult.Ok(WorkingCopy));
                    }
                    else
                    {
                        NavigationManager.NavigateTo($"{Urls.AdminUpdateContent}/{WorkingCopy.Id}");
                    }
                }
            }
        }
    }

    private Content CreateWorkingCopy(Content source)
    {
        var workingCopy = new Content();
        source.MapTo(workingCopy);
        
        // Deep-copy Path list (MapTo only copies reference)
        workingCopy.Path = new List<Guid>(source.Path);
        
        // Deep-copy PropertyData list
        workingCopy.PropertyData = new List<ContentPropertyValue>(source.PropertyData.Select(pd => new ContentPropertyValue
        {
            Id = pd.Id,
            ContentTypePropertyId = pd.ContentTypePropertyId,
            Alias = pd.Alias,
            Value = pd.Value,
            ContentId = pd.ContentId,
            DateCreated = pd.DateCreated,
            DateUpdated = pd.DateUpdated
        }));
        
        // Deep-copy pending block list changes
        foreach (var kvp in source.PendingBlockListChanges)
        {
            workingCopy.PendingBlockListChanges[kvp.Key] = new Dictionary<Guid, Content>(kvp.Value);
        }
        
        return workingCopy;
    }

    public void Dispose()
    {
        // Unsubscribe from events
        AppState.OnContentChanged -= HandleContentChanged;
    }
}