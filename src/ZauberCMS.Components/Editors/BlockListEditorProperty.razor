@using System.Text.Json
@using ZauberCMS.Components.Editors.Models
@using ZauberCMS.Components.Editors.Settings
@using ZauberCMS.Components.Editors.Components
@using ZauberCMS.Core.Content.Parameters
@using ZauberCMS.Core.Content.Mapping
@using ZauberCMS.Core.Content.Models
@implements ZauberCMS.Core.Content.Interfaces.IContentProperty

<!-- Load frontend stylesheets once for all previews -->
@if (SettingsModel.Styleheets.Any())
{
    foreach (var stylesheet in SettingsModel.Styleheets)
    {
        <link rel="stylesheet" href="@stylesheet" />
    }
}

<div class="block-list-editor @(IsDragging ? "dragging-active" : "")">
    @if (State.Items.Any())
    {
        <!-- Top drop zone -->
        <BlockListDropZone Index="0" 
                          OnInsert="HandleInsert" 
                          OnDrop="HandleDropAtIndex"
                          IsDragging="@IsDragging" />
        
        @for (var i = 0; i < State.Items.Count; i++)
        {
            var item = State.Items[i];
            var itemIndex = i; // Capture for closures
            
            @if (State.ContentTypes.TryGetValue(item.ContentTypeId, out var contentType))
            {
                <BlockListItem @key="item.Id"
                              Content="@item"
                              ContentType="@contentType"
                              Index="@itemIndex"
                              Stylesheets="@SettingsModel.Styleheets"
                              OnEdit="HandleEdit"
                              OnDelete="HandleDelete"
                              OnDropOnItem="HandleDropOnItem"
                              OnDragStart="HandleDragStart"
                              OnDragEnd="HandleDragEnd" />
                
                <!-- Drop zone between items -->
                @if (itemIndex < State.Items.Count - 1)
                {
                    <BlockListDropZone Index="@(itemIndex + 1)" 
                                      OnInsert="HandleInsert" 
                                      OnDrop="HandleDropAtIndex"
                                      IsDragging="@IsDragging" />
                }
            }
        }
    }
    
    <!-- Add New Block Button -->
    <RadzenStack Orientation="Orientation.Vertical" Gap="0.2rem" class="rz-pt-3" 
                 JustifyContent="JustifyContent.Center" AlignItems="AlignItems.Center">
        <RadzenButton Icon="add" Size="ButtonSize.Medium" 
                     Click="@(() => HandleInsert(State.Items.Count))" 
                     class="rz-border-radius-10" />
        <div class="text-sm">Add New Block</div>
    </RadzenStack>
</div>

@code {
    // IContentProperty implementation
    public string Name { get; set; } = "Block List Editor";
    public string Alias { get; set; } = "ZauberCMS.BlockListEditor";
    public string Description { get; set; } = "Creates a list of content blocks with drag-and-drop ordering";
    public string Icon { get; set; } = "format_align_justify";
    public Type? SettingsComponent { get; set; } = typeof(BlockListEditorSettings);
    public List<string> Scripts { get; set; } = [];
    public List<string> Styles { get; set; } = [];
    public bool FullWidth { get; set; }
    
    [Parameter] public string? Value { get; set; } = string.Empty;
    [Parameter] public string? Settings { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public Content? Content { get; set; }
    [Parameter] public string? PropertyAlias { get; set; }
    
    // BlockListEditor-specific parameters (not part of IContentProperty)
    [Parameter] public Action<BlockListChanges>? ChangesPending { get; set; }
    
    [CascadingParameter] public IModalService? ModalService { get; set; }
    [Inject] public DialogService DialogService { get; set; } = null!;
    [Inject] public NotificationService NotificationService { get; set; } = null!;
    
    private BlockListState State { get; set; } = new();
    private BlockListEditorSettingsModel SettingsModel { get; set; } = new();
    private bool IsDragging { get; set; }
    private int? DragSourceIndex { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        SettingsModel = Settings.FromJson<BlockListEditorSettingsModel>();
        
        // Load content types
        var contentTypes = await ContentService.QueryContentTypesAsync(new QueryContentTypesParameters 
        { 
            AmountPerPage = 300, 
            OnlyElementTypes = true
        });
        
        var contentTypesDict = contentTypes.Items.ToDictionary(x => x.Id, x => x);
        State = State with { ContentTypes = contentTypesDict };
        
        // Load existing content items
        if (!Value.IsNullOrWhiteSpace())
        {
            await LoadContentItems();
        }
    }
    
    private async Task LoadContentItems()
    {
        List<Guid> contentIds;
        try
        {
            contentIds = JsonSerializer.Deserialize<List<Guid>>(Value!) ?? [];
        }
        catch (JsonException)
        {
            contentIds = [];
        }
        
        if (!contentIds.Any()) return;
        
        var contentResult = await ContentService.QueryContentAsync(new QueryContentParameters 
        { 
            Ids = contentIds, 
            AmountPerPage = 100, 
            NestedFilter = BaseQueryContentParameters.NestedContentFilter.Only, 
            IncludeUnpublished = true 
        });
        
        // Preserve original order
        var idOrder = contentIds
            .Select((id, index) => new { id, index })
            .ToDictionary(x => x.id, x => x.index);
        
        var orderedItems = contentResult.Items
            .OrderBy(item => idOrder.TryGetValue(item.Id, out var idx) ? idx : int.MaxValue)
            .ToList();
        
        // Set ContentTypeAlias for rendering
        foreach (var item in orderedItems)
        {
            if (State.ContentTypes.TryGetValue(item.ContentTypeId, out var contentType))
            {
                item.ContentTypeAlias = contentType.Alias;
            }
        }
        
        State = State with { Items = orderedItems };
    }
    
    private async Task HandleInsert(int insertIndex)
    {
        await OpenContentEditor(null, insertIndex);
    }
    
    private async Task HandleEdit(int index)
    {
        if (index >= 0 && index < State.Items.Count)
        {
            await OpenContentEditor(State.Items[index], null);
        }
    }
    
    private async Task HandleDelete(int index)
    {
        if (index < 0 || index >= State.Items.Count) return;
        
        var content = State.Items[index];
        var confirmed = await DialogService.Confirm(
            "Are you sure you want to delete this block?", 
            "Delete Block", 
            new ConfirmOptions { OkButtonText = "Yes", CancelButtonText = "No" }
        );
        
        if (confirmed == true)
        {
            State = State.DeleteItem(content.Id);
            await NotifyChanges();
        }
    }
    
    private void HandleDragStart(int sourceIndex)
    {
        IsDragging = true;
        DragSourceIndex = sourceIndex;
        StateHasChanged();
    }
    
    private void HandleDragEnd()
    {
        IsDragging = false;
        DragSourceIndex = null;
        StateHasChanged();
    }
    
    private async Task HandleDropOnItem(int targetIndex)
    {
        // User dropped on an item - reorder to that position
        if (DragSourceIndex.HasValue && DragSourceIndex.Value != targetIndex)
        {
            State = State.ReorderItems(DragSourceIndex.Value, targetIndex);
            await NotifyChanges();
            StateHasChanged();
        }
    }
    
    private async Task HandleDropAtIndex(int targetIndex)
    {
        // User dropped in a drop zone between items
        if (DragSourceIndex.HasValue)
        {
            // Adjust target index if dragging down (because drop zone index is +1 of the item before it)
            var adjustedTarget = DragSourceIndex.Value < targetIndex ? targetIndex - 1 : targetIndex;
            
            if (DragSourceIndex.Value != adjustedTarget)
            {
                State = State.ReorderItems(DragSourceIndex.Value, adjustedTarget);
                await NotifyChanges();
                StateHasChanged();
            }
        }
    }
    
    private async Task OpenContentEditor(Content? contentToEdit, int? insertAtIndex)
    {
        var contentParams = new Dictionary<string, object>
        {
            { nameof(ContentEditor.IsBlockList), true },
            { nameof(ContentEditor.NestedParentId), Content!.Id },
            { nameof(ContentEditor.OnBlockListChanges), new Action<BlockListChanges>(HandleNestedChanges) }
        };
        
        // Filter allowed element types if configured
        if (SettingsModel.AllowedElementTypeIds.Any())
        {
            contentParams.Add(nameof(ContentEditor.AllowedElementTypeIds), SettingsModel.AllowedElementTypeIds.ToList());
        }
        
        if (contentToEdit != null)
        {
            contentParams.Add(nameof(ContentEditor.Content), contentToEdit);
        }
        else
        {
            contentParams.Add(nameof(ContentEditor.DefaultName), $"Block {(State.Items.Count + 1).ToWords()}");
        }
        
        if (ModalService == null) return;
        
        var dialog = ModalService.OpenSidePanel<ContentEditor>("Edit Content Block", contentParams);
        var result = await dialog.Result;
        
        if (result is { Confirmed: true, Data: Content savedContent })
        {
            // Block list items are saved in-memory only (deferred save when parent is saved)
            // Create a new Content instance to force Blazor change detection (same pattern as old implementation)
            var contentToStore = new Content();
            savedContent.MapTo(contentToStore);
            contentToStore.PropertyData = savedContent.PropertyData;
            
            // Deep-copy pending block list changes for nested content preview support
            foreach (var kvp in savedContent.PendingBlockListChanges)
            {
                contentToStore.PendingBlockListChanges[kvp.Key] = new Dictionary<Guid, Content>(kvp.Value);
            }
            
            // Ensure ContentType is loaded
            if (!State.ContentTypes.ContainsKey(contentToStore.ContentTypeId))
            {
                var contentType = await ContentService.GetContentTypeAsync(
                    new GetContentTypeParameters { Id = contentToStore.ContentTypeId }
                );
                
                if (contentType != null)
                {
                    State = State.SetContentType(contentType);
                }
            }
            
            // Set ContentTypeAlias for rendering
            if (State.ContentTypes.TryGetValue(contentToStore.ContentTypeId, out var ct))
            {
                contentToStore.ContentTypeAlias = ct.Alias;
            }
            
            if (contentToEdit != null)
            {
                // Update existing item with new instance
                State = State.UpdateItem(contentToStore);
            }
            else
            {
                // Add new item
                State = State.AddItem(contentToStore, insertAtIndex);
            }
            
            await NotifyChanges();
            StateHasChanged();
        }
    }
    
    private async void HandleNestedChanges(BlockListChanges nestedChanges)
    {
        // Merge nested changes into our state for proper change tracking and saving
        State = State.MergeNestedChanges(nestedChanges);

        // Update the property value and notify parent to trigger preview re-rendering
        await NotifyChanges();

        // Also notify parent immediately with the nested changes
        ChangesPending?.Invoke(nestedChanges);

        // Trigger local re-rendering as well
        StateHasChanged();
    }
    
    private async Task NotifyChanges()
    {
        // Update Value with current item IDs
        var serializedIds = State.GetSerializedIds();
        Value = JsonSerializer.Serialize(serializedIds);
        await ValueChanged.InvokeAsync(Value);
        
        // Store current items in Content.PendingBlockListChanges for preview access
        // This enables nested content previews to show live edits before database save
        if (Content != null && !string.IsNullOrWhiteSpace(PropertyAlias))
        {
            // Convert items list to dictionary for efficient lookup by GetBlocks()
            var itemsDict = State.Items.ToDictionary(x => x.Id, x => x);
            Content.PendingBlockListChanges[PropertyAlias] = itemsDict;
        }
        
        // Notify parent of all pending changes for database persistence
        var changes = State.GetChanges();
        ChangesPending?.Invoke(changes);
    }
}

