@using System.Collections.Concurrent
@using Microsoft.Extensions.Options
@using Microsoft.JSInterop
@using ZauberCMS.Core.Media.Models
@using ZauberCMS.Core.Media.Parameters
@using ZauberCMS.Core.Settings
@using ZauberCMS.Core.Shared.Models
@using ZauberCMS.Core.Shared
@using ZauberCMS.Core.Providers
@implements IAsyncDisposable

<RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Center" Gap="0" class="pb-1">
    @if (EnableFolderSelection)
    {
            <RadzenButton Click="@(() => AddMedia())" Variant="Variant.Text">Select Folder</RadzenButton> 
    }
    @if (ParentFolder != null)
    {
        <RadzenIcon Icon="@ParentFolder.MediaType.GetIcon()"/> 
        @ParentFolder.Name
    }
</RadzenStack>

<RadzenStack Visible="@FilesToUpload.Any()" Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Start" Gap="0" class="image-container w-full">
    @foreach (var media in FilesToUpload)
    {
        <PickerItem Icon="@media.Name.ToFileType().GetIcon()" Text="@media.Name" Close="@(() => RemoveMedia(media))" />
    }
</RadzenStack>

<div @ref="FileDropContainer" class="file-drop-zone @HoverClass" @ondragenter="OnDragEnter" @ondragleave="OnDragLeave" @ondragover="OnDragEnter">
    <div class="text-center">
        <label for="file-upload" style="cursor: pointer; position: relative; font-weight: 600; text-decoration: underline; padding: 30px 40px;">
            <InputFile OnChange="@OnChange" @ref="InputFile" multiple="@(MaxAllowedFiles > 1 ? "multiple" : null)" />
        </label>
    </div>
</div>

<RadzenButton Click="@(() => Save())">Save</RadzenButton>
<RadzenButton Click="@(() => Clear())">Clear</RadzenButton>

<RadzenStack Visible="@ErrorMessages.Any()" Orientation="Orientation.Vertical" JustifyContent="JustifyContent.Left" AlignItems="AlignItems.Start" Gap="0" class="error-message-container">
    @foreach (var error in ErrorMessages)
    {
        <RadzenAlert AlertStyle="AlertStyle.Danger" Variant="Variant.Flat" Shade="Shade.Lighter">
            @error.Message
        </RadzenAlert>
    }
</RadzenStack>

@code {
    [Inject] public IJSRuntime JsRuntime { get; set; } = null!;
    [Inject] public ProviderService ProviderService { get; set; } = null!;
    [Inject] public IOptions<ZauberSettings> Settings { get; set; } = null!;
    [Inject] public NotificationService NotificationService { get; set; } = null!;
    [Inject] public AppState AppState { get; set; } = null!;
    [Inject] public TreeState TreeState { get; set; } = null!;
    
    [Parameter] public string? ParentId { get; set; }
    [Parameter] public int MaxAllowedFiles { get; set; } = 30; // Only allow 30 max at a time, should be setting
    [Parameter] public bool OnlyImages { get; set; }
    [Parameter] public bool EnableFolderSelection { get; set; }
    [Parameter] public EventCallback<List<Media>> ValueChanged { get; set; }
    [Parameter] public EventCallback<List<IBrowserFile>> OnSave { get; set; }
    [Parameter] public List<IBrowserFile> FilesToUpload { get; set; } = [];
    
    [CascadingParameter] public IModalService? ModalService { get; set; }
    
    private ElementReference FileDropContainer { get; set; }
    private InputFile InputFile { get; set; } = null!;
    private IJSObjectReference? FilePasteModule { get; set; }
    private IJSObjectReference? FilePasteFunctionReference { get; set; }
    private string HoverClass { get; set; } = string.Empty;
    private List<ResultMessage> ErrorMessages { get; set; } = [];
    private Media? ParentFolder { get; set; }
    private IModalReference? Modal { get; set; }
    private ConcurrentDictionary<string, bool>? HasChildrenCache { get; set; } = new();

    protected override async Task OnParametersSetAsync()
    {
        if (ParentId != null)
        {
            var media = await MediaService.GetMediaAsync(new GetMediaParameters { Id = ParentId });
            if (media is { MediaType: MediaType.Folder })
            {
                ParentFolder = media;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            FilePasteModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/ZauberCMS.Components/Editors/MultipleMediaUpload.razor.js");
            FilePasteFunctionReference = await FilePasteModule.InvokeAsync<IJSObjectReference>("initializeFilePaste", FileDropContainer, InputFile.Element);
        }
    }

    void OnDragEnter(DragEventArgs e) => HoverClass = "hover";
    void OnDragLeave(DragEventArgs e) => HoverClass = string.Empty;

    private async Task AddMedia()
    {
        var foldersOnly = await MediaService.QueryMediaAsync(new QueryMediaParameters
        {
            MediaTypes = [MediaType.Folder],
            OrderBy = GetMediaOrderBy.Name,
            AmountPerPage = 250,
            WhereClause = x => x.ParentId == null
        });
        
        var parameters = new Dictionary<string, object>
        {
            { nameof(MediaTree.ValueChanged), EventCallback.Factory.Create<object>(this, OnValueChangedHandler) },
            { nameof(MediaTree.DisableContextMenu), true },
            { nameof(MediaTree.Data), foldersOnly.Items },
            { nameof(MediaTree.OnExpand), EventCallback.Factory.Create<TreeExpandEventArgs>(this, OnExpandHandler) }
        };

        Modal = ModalService?.OpenSidePanel<MediaTree>("Choose Media", parameters);
    }
    
    private void OnValueChangedHandler(object value)
    { 
        Modal?.Close();
        
        if (value is Media { MediaType: MediaType.Folder } media)
        {
            ParentFolder = media;
        }
    }
    
    private async Task OnExpandHandler(TreeExpandEventArgs args)
    {
        if (args.Value is Media media)
        {
            var items = await MediaService.QueryMediaAsync(new QueryMediaParameters
            {
                MediaTypes = [MediaType.Folder],
                WhereClause = x => x.ParentId == media.Id,
                OrderBy = GetMediaOrderBy.Name,
                AmountPerPage = 250
            });
            args.Children.Data = items.Items;
            args.Children.TextProperty = "Name";
            args.Children.Template = TreeExtensions.CreateMediaTreeTemplate<RadzenTreeItem>();
            args.Children.HasChildren = HasChildren;
            TreeState.NodeExpanded(media.Id);
        }
    }
    
    // Using same method from MediaTree. Would be nice to have a single place, so easier to re-use trees
    private bool HasChildren(object data)
    {
        if (data is Media { MediaType: MediaType.Folder } media)
        {
            // Check if result is cached
            if (HasChildrenCache!.TryGetValue(media.Id, out var hasChildren))
            {
                return hasChildren;
            }

            // Calculate result and cache it
            hasChildren = Task.Run(() => MediaService.HasChildMediaAsync(new HasChildMediaParameters { ParentId = media.Id })).GetAwaiter().GetResult();
            HasChildrenCache[media.Id] = hasChildren;

            return hasChildren;
        }

        return false;
    }
    
    private void RemoveMedia(IBrowserFile media)
    {
        var index = FilesToUpload.FindIndex(c => c.Name == media.Name);
        if (index != -1)
        {
            FilesToUpload.RemoveAt(index);
        }
    }

    private async Task OnChange(InputFileChangeEventArgs e)
    {
        ErrorMessages.Clear();
        
        if ((e.FileCount + FilesToUpload.Count) > MaxAllowedFiles)
        {
            ErrorMessages.Add(new ResultMessage{Message = $"Only {MaxAllowedFiles} files can be uploaded", MessageType = ResultMessageType.Error});
            return;
        }

        foreach (var file in e.GetMultipleFiles(MaxAllowedFiles))
        {
            var result = await ProviderService.StorageProvider!.CanUseFile(file, OnlyImages);
            if (result.Success)
            {
                FilesToUpload.Add(file);
            }
            else
            {
                ErrorMessages.AddRange(result.Messages.ErrorMessages());
            }
            /*await using var stream = file.OpenReadStream(Settings.Value.MaxUploadFileSizeInBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);*/
            //ImageSources.Add($"data:{file.ContentType};base64,{Convert.ToBase64String(ms.ToArray())}");
        }

        HoverClass = string.Empty;
    }

    private async Task Save()
    {
        if (OnSave.HasDelegate)
        {
            await OnSave.InvokeAsync(FilesToUpload);
        }
        else
        {
            // Clear caches BEFORE saving to ensure fresh data after save
            if (ParentFolder != null)
            {
                TreeState.ClearChildCache(ParentFolder.Id);
            }
            else
            {
                // If saving to root, clear all caches
                TreeState.ClearChildCache(null);
            }
            
            // Clear local component cache
            HasChildrenCache?.Clear();
            
            var savedMediaItems = new List<Media>();
            foreach (var browserFile in FilesToUpload)
            {
                var result = await MediaService.SaveMediaAsync(new SaveMediaParameters
                {
                    FileToSave = browserFile,
                    ParentFolderId = ParentFolder?.Id
                });

                if (!result.Success)
                {
                    ErrorMessages.AddRange(result.Messages);
                }
                else
                {
                    savedMediaItems.Add(result.Entity!);
                }
            }
            
            FilesToUpload.Clear();
            
            // Ensure parent folder stays expanded if it was expanded
            if (ParentFolder != null && TreeState.IsNodeExpanded(ParentFolder.Id))
            {
                TreeState.NodeExpanded(ParentFolder.Id);
            }
            
            if (ValueChanged.HasDelegate)
            {
                await ValueChanged.InvokeAsync(savedMediaItems);
            }
            else
            {
                NotificationService.ShowSuccessNotification($"{savedMediaItems.Count} Media Saved");
            }
        }
    }

    private void Clear()
    {
        FilesToUpload.Clear();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (FilePasteFunctionReference != null)
            {
                await FilePasteFunctionReference.InvokeVoidAsync("dispose");
                await FilePasteFunctionReference.DisposeAsync();
            }

            if (FilePasteModule != null)
            {
                await FilePasteModule.DisposeAsync();
            }
        }
        catch (JSDisconnectedException)
        {
            // Circuit has disconnected, JS interop is no longer available
            // This is expected during page navigation or circuit disconnect
        }
        catch (Exception)
        {
            // Silently handle other disposal errors to prevent unhandled exceptions
        }
    }

}