<div class="block-drop-zone @(IsHovered ? "active" : "") @(IsInsertMode ? "insert-mode" : "drop-mode")"
     @onmousemove="HandleMouseMove"
     @onmouseenter="HandleMouseEnter"
     @onmouseleave="HandleMouseLeave"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault
     @ondragenter="HandleDragEnter"
     @ondragleave="HandleDragLeave"
     @ondrop="HandleDrop"
     @onclick="HandleClick">
   
    <div class="drop-zone-content">
        <div class="drop-zone-icon" style="left: @(IconLeftPosition)px">
            <RadzenIcon Icon="add" Style="font-size: 1.2rem"/>
        </div>
    </div>
</div>

<style>
    .block-drop-zone {
        position: relative;
        height: 12px;
        margin: -4px 0;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .block-drop-zone.insert-mode {
        cursor: pointer;
    }
    
    .block-drop-zone.drop-mode {
        cursor: move;
    }
    
    .drop-zone-content {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
    }
    
    /* Only show drop zone content during drag operations */
    .block-drop-zone.drop-mode.active .drop-zone-content,
    .block-drop-zone.drop-mode:hover .drop-zone-content {
        opacity: 1;
    }
    
    /* Insert mode shows content on hover without animation */
    .block-drop-zone.insert-mode:hover .drop-zone-content {
        opacity: 1;
    }
    
    .drop-zone-icon {
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: var(--rz-primary);
        color: var(--rz-on-primary);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        z-index: 10;
        transform: translateX(-50%);
        transition: left 0.05s ease-out, box-shadow 0.2s ease, background-color 0.2s ease;
        pointer-events: none;
    }
    
    /* Enhanced glow during drag operations */
    .block-drop-zone.drop-mode.active .drop-zone-icon,
    .block-drop-zone.drop-mode:hover .drop-zone-icon {
        background-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.3), 0 6px 24px rgba(37, 99, 235, 0.6);
    }
    
    /* Expand drop zone when hovering in insert mode */
    .block-drop-zone.insert-mode:hover {
        height: 32px;
        margin: -8px 0;
    }
</style>

@code {
    [Parameter, EditorRequired] public int Index { get; set; }
    [Parameter] public EventCallback<int> OnInsert { get; set; }
    [Parameter] public EventCallback<int> OnDrop { get; set; }
    [Parameter] public bool IsDragging { get; set; }
    
    private bool IsHovered { get; set; }
    private bool IsMouseInside { get; set; }
    private double IconLeftPosition { get; set; } = 50; // Start at a reasonable position
    private bool IsInsertMode => !IsDragging;
    
    private void HandleMouseMove(MouseEventArgs e)
    {
        if (!IsInsertMode || !IsMouseInside) return;
        
        // Use offsetX which gives position relative to the element - no JS interop needed!
        var iconRadius = 16; // Half of 32px icon width
        
        // e.OffsetX is relative to the element we're hovering over
        IconLeftPosition = Math.Max(iconRadius, e.OffsetX);
    }
    
    private void HandleMouseEnter(MouseEventArgs e)
    {
        IsMouseInside = true;
        
        if (IsInsertMode)
        {
            // Get initial position
            HandleMouseMove(e);
        }
    }
    
    private void HandleMouseLeave(MouseEventArgs e)
    {
        IsMouseInside = false;
        // Don't reset position - keep it where it was so it doesn't jump when opacity fades out
    }
    
    private void HandleDragOver(DragEventArgs e)
    {
        // This is called continuously while dragging over - no logging to avoid spam
        // The @ondragover:preventDefault handles the actual prevention
    }
    
    private void HandleDragEnter(DragEventArgs e)
    {
        IsHovered = true;
    }
    
    private void HandleDragLeave(DragEventArgs e)
    {
        IsHovered = false;
    }
    
    private async Task HandleDrop(DragEventArgs e)
    {
        IsHovered = false;
        await OnDrop.InvokeAsync(Index);
    }
    
    private async Task HandleClick()
    {
        if (!IsDragging)
        {
            await OnInsert.InvokeAsync(Index);
        }
    }
}

