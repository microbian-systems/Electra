@using System.Collections.Concurrent
@using ZauberCMS.Core
@using ZauberCMS.Core.Shared
@using ZauberCMS.Core.Media.Parameters
@using ZauberCMS.Core.Media.Models
@implements IDisposable

<BaseTree T="Media"
          Data="@Data"
          TreeAlias="@Constants.Sections.Trees.MediaTree"
          Expand="@OnExpandHandler"
          Change="@OnChangeHandler"
          @bind-Value="@Value"
          HasChildren="@(e => HasChildren(e))"
          ShouldBeExpanded="@(e => ShouldBeExpanded(e))"
          DisableContextMenu="DisableContextMenu"
          DisableSectionOnlyContextMenu="DisableSectionOnlyContextMenu"
          Template="@(TreeExtensions.CreateMediaTreeTemplate<object>())">
</BaseTree>

@code {
    [Inject] public AppState AppState { get; set; } = null!;
    [Inject] public TreeState TreeState { get; set; } = null!;
    [Inject] public ContextMenuService ContextMenuService { get; set; } = null!;
    [Inject] public NotificationService NotificationService { get; set; } = null!;

    [Parameter] public IEnumerable<Media> Data { get; set; } = [];
    [Parameter] public List<MediaType> MediaTypes { get; set; } = [];
    [Parameter] public EventCallback<TreeExpandEventArgs> OnExpand { get; set; }
    [Parameter] public EventCallback OnChange { get; set; }
    [Parameter] public EventCallback<TreeItemContextMenuEventArgs> OnItemContextMenu { get; set; }
    [Parameter] public object? Value { get; set; }
    [Parameter] public EventCallback<object> ValueChanged { get; set; }
    [Parameter] public bool DisableContextMenu { get; set; }
    [Parameter] public bool DisableSectionOnlyContextMenu { get; set; }
    [CascadingParameter] public IModalService? ModalService { get; set; }

    // Dictionary to cache HasChildren results
    private ConcurrentDictionary<string, bool>? _hasChildrenCache;

    protected override void OnInitialized()
    {
        AppState.OnMediaChanged += HandleMediaChanged;
        // Initialize the cache
        _hasChildrenCache = new ConcurrentDictionary<string, bool>();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!Data.Any())
        {
            await DataRefresh();
        }
    }

    private async Task HandleMediaChanged(Media? media, string username)
    {
        _hasChildrenCache?.Clear();
        
        // Also clear TreeState cache to ensure full refresh
        TreeState.ClearChildCache(null);

        // If on change hasn't got a delegate,
        // it's likely this is being used as a standalone tree
        // so need to handle data refresh (This needs thinking about a bit more)
        if (!OnChange.HasDelegate)
        {
            await DataRefresh();
        }
        StateHasChanged();
    }

    private async Task DataRefresh()
    {
        var mediaTypesToQuery = GetMediaTypesForQuery();
        
        var items = await MediaService.QueryMediaAsync(new QueryMediaParameters
        {
            MediaTypes = mediaTypesToQuery,
            AmountPerPage = 250,
            WhereClause = x => x.ParentId == null,
            IncludeChildren = true,
            OrderBy = GetMediaOrderBy.Name
        });
        Data = items.Items;
    }
    
    // Public method to allow external refresh
    public async Task RefreshData()
    {
        _hasChildrenCache?.Clear();
        TreeState.ClearChildCache(null);
        
        // If this tree is standalone (no parent controlling data via OnChange delegate),
        // refresh data internally. Otherwise, let the parent handle data refresh.
        if (!OnChange.HasDelegate)
        {
            await DataRefresh();
        }
        
        StateHasChanged();
    }
    
    private async Task OnExpandHandler(TreeExpandEventArgs args)
    {
        if (OnExpand.HasDelegate)
        {
            await OnExpand.InvokeAsync(args);
        }
        else
        {
            if (args.Value is Media media)
            {
                var mediaTypesToQuery = GetMediaTypesForQuery();
                
                var items = MediaService.QueryMediaAsync(new QueryMediaParameters
                {
                    MediaTypes = mediaTypesToQuery,
                    WhereClause = x => x.ParentId == media.Id,
                    OrderBy = GetMediaOrderBy.Name,
                    AmountPerPage = 250
                }).GetAwaiter().GetResult();
                args.Children.Data = items.Items;
                args.Children.TextProperty = "Name";
                args.Children.Template = TreeExtensions.CreateMediaTreeTemplate<RadzenTreeItem>();
                args.Children.HasChildren = HasChildren;
                TreeState.NodeExpanded(media.Id);
            }
        }
    }

    private async Task OnChangeHandler()
    {
        await ValueChanged.InvokeAsync(Value);
        if (OnChange.HasDelegate)
        {
            await OnChange.InvokeAsync();
        }
    }

    private List<MediaType> GetMediaTypesForQuery()
    {
        if (MediaTypes.Any())
        {
            // Always include folders for navigation, and add the specified media types
            var typesToQuery = new List<MediaType> { MediaType.Folder };
            typesToQuery.AddRange(MediaTypes.Where(mt => mt != MediaType.Folder));
            return typesToQuery;
        }
        
        // If no MediaTypes specified, return empty list (which means all types)
        return [];
    }

    private bool HasChildren(object data)
    {
        if (data is Media { MediaType: MediaType.Folder } media)
        {
            // Check if result is cached
            if (_hasChildrenCache!.TryGetValue(media.Id, out var hasChildren))
            {
                return hasChildren;
            }

            // Calculate result and cache it
            hasChildren = Task.Run(() => MediaService.HasChildMediaAsync(new HasChildMediaParameters { ParentId = media.Id })).GetAwaiter().GetResult();
            _hasChildrenCache[media.Id] = hasChildren;

            return hasChildren;
        }

        return false;
    }

    private bool ShouldBeExpanded(object data)
    {
        if (data is Media { MediaType: MediaType.Folder } media)
        {
            return TreeState.IsNodeExpanded(media.Id);
        }
        return false;
    }

    public void Dispose()
    {
        AppState.OnMediaChanged -= HandleMediaChanged;
    }

}