using Aero.Core.Http;
using System.Text.Json;
using System.Text;
using Hashnode;
using microbians.io.web.Areas.Blog.Models;
using GraphQL.Client.Http;
using GraphQL.Client.Abstractions;
using GraphQL.Client.Http.Websocket;
using GraphQL;
using GraphQL.SystemTextJson;
using GraphQL.Client.Serializer.SystemTextJson;

namespace microbians.io.web.Areas.Blog.Services;

public interface IHashnodeApiClient
{
    Task<List<Node>> GetAllPostsAsync(CancellationToken cancellationToken = default);
    Task<Node?> GetPostBySlugAsync(string slug, CancellationToken cancellationToken = default);
}

public sealed class HashnodeApiClient : IHashnodeApiClient, IDisposable
{
    private readonly string _graphqlQuery;
    private readonly IGraphQLClient _graphQLClient;
    private readonly ILogger<HashnodeApiClient> _log;
    readonly string apiKey;

    public HashnodeApiClient(HttpClient httpClient, IConfiguration config, ILogger<HashnodeApiClient> log) 
    {
        _log = log;
        // Load the GraphQL query from the embedded file
        _graphqlQuery = LoadGraphqlQuery();
        apiKey = config.GetValue<string>("HashnodeApiKey") ?? string.Empty;

        if(string.IsNullOrEmpty(apiKey))
        {
            _log.LogWarning("Hashnode API key is not configured. Requests may be limited.");
        }

        httpClient.DefaultRequestHeaders.Add("Authorization", apiKey);
        // Create GraphQL client with the configured HttpClient
        _graphQLClient = new GraphQLHttpClient(
            new GraphQLHttpClientOptions
            {
                
                EndPoint = httpClient.BaseAddress ?? new Uri("https://gql.hashnode.com/")
            },
            new SystemTextJsonSerializer(),
            httpClient);
    }

    public async Task<List<Node>> GetAllPostsAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            var result = await ExecuteGraphqlQueryAsync(cancellationToken);
            return result?.Data?.Publication?.Posts?.Edges?.Select(e => e.Node)?.ToList() ?? new List<Node>();
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Error getting all posts from Hashnode");
            return new List<Node>();
        }
    }

    public async Task<Node?> GetPostBySlugAsync(string slug, CancellationToken cancellationToken = default)
    {
        try
        {
            var allPosts = await GetAllPostsAsync(cancellationToken);
            return allPosts.FirstOrDefault(p => p.Slug.Equals(slug, StringComparison.OrdinalIgnoreCase));
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Error getting post with slug {Slug} from Hashnode", slug);
            return null;
        }
    }

    private async Task<HashnodeViewModel?> ExecuteGraphqlQueryAsync(CancellationToken cancellationToken)
    {
        try
        {
            var graphqlRequest = new GraphQLRequest
            {
                Query = _graphqlQuery
            };

            _log.LogDebug("Executing GraphQL query against Hashnode");
            
            var response = await _graphQLClient.SendQueryAsync<HashnodeViewModel>(graphqlRequest, cancellationToken);

            if (response.Errors?.Any() == true)
            {
                _log.LogError("Hashnode GraphQL errors: {Errors}", 
                    string.Join(", ", response.Errors.Select(e => e.Message)));
                return null;
            }

            _log.LogDebug("Successfully received Hashnode GraphQL response");
            return response.Data;
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "GraphQL exception occurred while querying Hashnode");
            return null;
        }
    }

    private string LoadGraphqlQuery()
    {
        // Try multiple possible paths for the GraphQL file
        var possiblePaths = new[]
        {
            Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Areas", "Blog", "Data", "blog.hashnode.graphql"),
            Path.Combine(Directory.GetCurrentDirectory(), "Areas", "Blog", "Data", "blog.hashnode.graphql"),
            Path.Combine(Path.GetDirectoryName(typeof(HashnodeApiClient).Assembly.Location) ?? "", "Areas", "Blog", "Data", "blog.hashnode.graphql")
        };

        foreach (var filePath in possiblePaths)
        {
            if (File.Exists(filePath))
            {
                _log.LogDebug("Loading GraphQL query from {FilePath}", filePath);
                return File.ReadAllText(filePath);
            }
        }
        
        _log.LogError("GraphQL query file not found at any of the expected paths: {Paths}", string.Join(", ", possiblePaths));
        throw new FileNotFoundException("GraphQL query file not found");
    }

    public void Dispose()
    {
        //_graphQLClient?.Dispose();
    }
}

public static class HashnodeApiExtensions
{
    public static IServiceCollection AddHashnodeApiClient(this IServiceCollection services, IConfiguration config)
    {
        // Configure options
        services.Configure<HashnodeApiOptions>(config.GetSection(HashnodeApiOptions.SectionName));
        
        // Register the delegating handler
        services.AddTransient<HashnodeApiHandler>();
        
        // Configure HttpClient with resilience
        services.AddHttpClient<IHashnodeApiClient, HashnodeApiClient>(client =>
        {
            // Basic client configuration - detailed config handled in the handler
            client.Timeout = TimeSpan.FromSeconds(30);
        })
        .AddHttpMessageHandler<HashnodeApiHandler>()
        .AddStandardResilienceHandler(options =>
        {
            // Configure retry policy
            options.Retry.MaxRetryAttempts = 3;
            options.Retry.Delay = TimeSpan.FromSeconds(1);
            options.Retry.BackoffType = Polly.DelayBackoffType.Exponential;
            
            // Configure circuit breaker
            options.CircuitBreaker.SamplingDuration = TimeSpan.FromSeconds(30);
            options.CircuitBreaker.FailureRatio = 0.5;
            options.CircuitBreaker.MinimumThroughput = 5;
            options.CircuitBreaker.BreakDuration = TimeSpan.FromSeconds(15);
            
            // Configure timeout
            options.TotalRequestTimeout.Timeout = TimeSpan.FromSeconds(30);
        });

        return services;
    }
}